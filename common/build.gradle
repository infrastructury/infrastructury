buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "net.fabricmc:tiny-remapper:0.10.1"
    }
}

plugins {
    id 'java'
}

architectury {
    common(rootProject.builds_for.split(","))
}

loom {
    accessWidenerPath = file("src/main/resources/omniplay.accesswidener")
}

configurations {
    compile
    mappings
}

import java.security.MessageDigest
import java.io.File

var mappingsProjectDir = project(":mappings").projectDir.toPath()
var mappingsTiny = mappingsProjectDir.resolve("arch_${rootProject.architectury_version}.tiny")
var hashHex = HexFormat.of().formatHex(MessageDigest.getInstance("SHA-1").digest((new File(mappingsTiny.toUri())).readBytes()))
var remappedArchPath = rootProject.projectDir.toPath().resolve(".gradle/remapped_architectury_cache/remapped_architectury_${rootProject.architectury_version}_${hashHex}.jar")

dependencies {
    // We depend on fabric loader here to use the fabric @Environment annotations and get the mixin dependencies
    // Do NOT use other classes from fabric loader
    modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
    // Remove the next line if you don't want to depend on the API
    modApi "${rootProject.architectury_group}:architectury:${rootProject.architectury_version}"

    modApi("me.shedaniel.cloth:cloth-config-fabric:${rootProject.cloth_config_version}") {
        exclude(group: "net.fabricmc.fabric-api")
    }
    modApi("com.terraformersmc:modmenu:${rootProject.modmenu_version}") {
        exclude(group: "net.fabricmc.fabric-api")
    }

    compileOnlyApi files(remappedArchPath)
}


import net.fabricmc.tinyremapper.NonClassCopyMode
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils

gradle.projectsEvaluated {
    tasks.register('applyMappings') {
        if (new File(remappedArchPath.toUri()).exists()) {
            println "Remapped Architectury is already up-to-date"
            return
        }

        var archJarPath = "/${rootProject.architectury_group.replaceAll("\\.", "/")}/architectury/${rootProject.architectury_version}/architectury-${rootProject.architectury_version}.jar"
        println "Searching for architectury jar: $archJarPath"
        File archJar = project.configurations.getByName('compileClasspath').files.find { it.path.endsWith(archJarPath) }
        println "Found matching jar: $archJar"
        println "Using mappings: $mappingsTiny"

        def remapper = TinyRemapper.newRemapper()
                .withMappings(TinyUtils.createTinyMappingProvider(mappingsTiny, "official", "named"))
                .renameInvalidLocals(false)
                .build()

        new File(remappedArchPath.toUri()).delete()

        try (OutputConsumerPath outputConsumer = new OutputConsumerPath.Builder(remappedArchPath).build()) {
            outputConsumer.addNonClassFiles(archJar.toPath(), NonClassCopyMode.FIX_META_INF, remapper)

            remapper.readInputs(archJar.toPath());
            remapper.readClassPath(archJar.toPath());

            remapper.apply(outputConsumer);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            remapper.finish();
        }

        println "Remapping completed successfully."
    }

    compileJava.dependsOn applyMappings
}

publishing {
    publications {
        mavenCommon(MavenPublication) {
            artifactId = rootProject.archives_base_name
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
    }
}

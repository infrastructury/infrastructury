buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "net.fabricmc:tiny-remapper:0.10.1"
    }
}

plugins {
    id 'java'
}

architectury {
    common(rootProject.builds_for.split(","))
}

loom {
    accessWidenerPath = file("src/main/resources/omniplay.accesswidener")
}

configurations {
    compile
    mappings
}



import net.fabricmc.tinyremapper.NonClassCopyMode
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils

import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.security.MessageDigest

var mappingsProjectDir = project(":mappings").projectDir.toPath()
var mappingsTiny = new File(mappingsProjectDir.resolve("arch_${rootProject.architectury_version}.tiny").toUri())
var hashHex = HexFormat.of().formatHex(MessageDigest.getInstance("SHA-1").digest(mappingsTiny.readBytes()))
var remappedArchPath = rootProject.projectDir.toPath().resolve(".gradle/remapped_architectury_cache/remapped_architectury_${rootProject.architectury_version}_${hashHex}.jar")

dependencies {
    // We depend on fabric loader here to use the fabric @Environment annotations and get the mixin dependencies
    // Do NOT use other classes from fabric loader
    modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
    // Remove the next line if you don't want to depend on the API
    modApi "${rootProject.architectury_group}:architectury:${rootProject.architectury_version}"

    modApi("me.shedaniel.cloth:cloth-config-fabric:${rootProject.cloth_config_version}") {
        exclude(group: "net.fabricmc.fabric-api")
    }
    modApi("com.terraformersmc:modmenu:${rootProject.modmenu_version}") {
        exclude(group: "net.fabricmc.fabric-api")
    }

    compileOnlyApi files(remappedArchPath)
}

static void runMappingsOnJar(File input, File output, File mappingsTiny, String fromM, String toM) {
    def remapper = TinyRemapper.newRemapper()
            .withMappings(TinyUtils.createTinyMappingProvider(mappingsTiny.toPath(), fromM, toM))
            .renameInvalidLocals(false)
            .build()

    output.delete()

    try (OutputConsumerPath outputConsumer = new OutputConsumerPath.Builder(output.toPath()).build()) {
        outputConsumer.addNonClassFiles(input.toPath(), NonClassCopyMode.FIX_META_INF, remapper)
        remapper.readInputs(input.toPath())
        remapper.readClassPath(input.toPath())
        remapper.apply(outputConsumer)
    } catch (IOException e) {
        throw new RuntimeException(e)
    } finally {
        remapper.finish()
    }
}

gradle.projectsEvaluated {
    tasks.register('applyMappings') {
        if (new File(remappedArchPath.toUri()).exists()) {
            println "Remapped Architectury is already up-to-date"
            return
        }

        var archJarPath = "/${rootProject.architectury_group.replaceAll("\\.", "/")}/architectury/${rootProject.architectury_version}/architectury-${rootProject.architectury_version}.jar"
        println "Searching for architectury jar: $archJarPath"
        File archJar = project.configurations.getByName('compileClasspath').files.find { it.path.endsWith(archJarPath) }
        println "Found matching jar: ${archJar.name}"
        println "Using mappings: ${mappingsTiny.name}"

        runMappingsOnJar(archJar, new File(remappedArchPath.toUri()), new File(mappingsTiny), "official", "named")

        println "Remapping completed successfully."
    }

    compileJava.dependsOn applyMappings

    tasks.register('undoApplyMappings') {
        doLast {
            File mergedJar = new File(rootProject.layout.projectDirectory.asFile, "Merged/${rootProject.forgix_merged_jar}")
            File remapFile = new File(mergedJar.parentFile, mergedJar.name + ".remapped.jar")
            runMappingsOnJar(mergedJar, remapFile, mappingsTiny, "named", "official")
            mergedJar.delete()
            Files.copy(remapFile.toPath(), mergedJar.toPath(), StandardCopyOption.REPLACE_EXISTING)
            remapFile.delete()
        }
    }

    rootProject.tasks['mergeJars'].finalizedBy undoApplyMappings
}

publishing {
    publications {
        mavenCommon(MavenPublication) {
            artifactId = rootProject.archives_base_name
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
    }
}
